/*! @file numpy_array_loader.cc
 *  @brief Numpy array loading tests.
 *  @author Markovtsev Vadim <v.markovtsev@samsung.com>
 *  @version 1.0
 *
 *  @section Notes
 *  This code partially conforms to <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">Google C++ Style Guide</a>.
 *
 *  @section Copyright
 *  Copyright 2015 Â© Samsung R&D Institute Russia
 *
 *  @section License
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */


#include <gtest/gtest.h>
#include <veles/logger.h>  // NOLINT(*)
#include "src/numpy_array_loader.h"
#include "src/imemstream.h"
#include "inc/veles/make_unique.h"

namespace veles {

namespace internal {

class NumpyArrayLoaderTest :
    public ::testing::TestWithParam<std::tuple<int, int>>,
    protected DefaultLogger<
        NumpyArrayLoaderTest, Logger::COLOR_VIOLET> {
};

void InitializeMatrix(float* matrix, int size) {
  for (int i = 0; i < size; i++) {
    matrix[i] = i;
  }
}

void Transpose(const float* src, float* dst, int rows, int cols) {
  for (int y = 0; y < rows; y++) {
    for (int x = 0; x < cols; x++) {
      dst[x * rows + y] = src[y * cols + x];
    }
  }
}

TEST_P(NumpyArrayLoaderTest, Transpose) {
  int rows, cols;
  std::tie(rows, cols) = GetParam();
  INF("Testing %d rows x %d cols...", rows, cols);
  int size = rows * cols;
  float matrix[size];
  InitializeMatrix(matrix, size);
  float reference[size];
  Transpose(matrix, reference, rows, cols);
  NumpyArrayLoader::TransposeInplace(rows, cols, matrix);
  ASSERT_EQ(std::memcmp(matrix, reference, sizeof(matrix)), 0);
  InitializeMatrix(matrix, size);
  NumpyArrayLoader::TransposeInplace(rows, cols, sizeof(float),
                                     reinterpret_cast<char*>(matrix));
  ASSERT_EQ(std::memcmp(matrix, reference, sizeof(matrix)), 0);
}

INSTANTIATE_TEST_CASE_P(
    NumpyArrayLoaderTests, NumpyArrayLoaderTest,
        ::testing::Values(std::make_tuple(10, 15),
                          std::make_tuple(9, 9),
                          std::make_tuple(9, 7),
                          std::make_tuple(8, 8),
                          std::make_tuple(7, 9),
                          std::make_tuple(7, 7),
                          std::make_tuple(1, 2),
                          std::make_tuple(2, 1),
                          std::make_tuple(1, 1)));

static const uint8_t NUMPY_ARRAY_SAMPLE[] = {
  0x93, 0x4e, 0x55, 0x4d, 0x50, 0x59, 0x01, 0x00, 0x46, 0x00,
  0x7b, 0x27, 0x64, 0x65, 0x73, 0x63, 0x72, 0x27, 0x3a, 0x20,
  0x27, 0x3c, 0x66, 0x32, 0x27, 0x2c, 0x20, 0x27, 0x66, 0x6f,
  0x72, 0x74, 0x72, 0x61, 0x6e, 0x5f, 0x6f, 0x72, 0x64, 0x65,
  0x72, 0x27, 0x3a, 0x20, 0x46, 0x61, 0x6c, 0x73, 0x65, 0x2c,
  0x20, 0x27, 0x73, 0x68, 0x61, 0x70, 0x65, 0x27, 0x3a, 0x20,
  0x28, 0x34, 0x30, 0x2c, 0x20, 0x31, 0x30, 0x29, 0x2c, 0x20,
  0x7d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a,
  0xe2, 0xdc, 0x71, 0xd2, 0x67, 0xd5, 0x00, 0xdd, 0xf7, 0xd4,
  0x24, 0xc4, 0x9e, 0xde, 0xa1, 0xcf, 0xb2, 0x5d, 0x46, 0xdf,
  0x33, 0xdd, 0x69, 0xde, 0xcc, 0x5e, 0xb4, 0x58, 0xc9, 0x5b,
  0x8a, 0x55, 0x68, 0x4f, 0xb2, 0xd9, 0xe3, 0x59, 0x2b, 0x58,
  0x75, 0xdd, 0x15, 0x5e, 0x6e, 0x4d, 0x9b, 0x4d, 0xad, 0x5f,
  0xb8, 0x5d, 0xa4, 0xdd, 0xd4, 0xd8, 0xa8, 0x59, 0xc9, 0xdc,
  0xed, 0xd9, 0x6f, 0x56, 0x39, 0x59, 0xca, 0xd6, 0x9e, 0xda,
  0x82, 0x58, 0x13, 0x58, 0x48, 0x5e, 0x3e, 0x55, 0x45, 0xde,
  0xa0, 0x57, 0xa6, 0xdd, 0x66, 0xdd, 0xf9, 0xdc, 0xf7, 0x5e,
  0x2e, 0x5d, 0x38, 0x55, 0xfe, 0x5d, 0x1a, 0xc5, 0x4a, 0x5d,
  0x5f, 0xde, 0xba, 0x57, 0x73, 0xdf, 0xdc, 0x53, 0x57, 0xde,
  0xb3, 0x5d, 0x87, 0xdf, 0xb4, 0xc4, 0x2c, 0xdc, 0x29, 0xd0,
  0x74, 0xdf, 0xb3, 0x5e, 0xca, 0x53, 0xb7, 0x5c, 0x7b, 0xd8,
  0xb1, 0xdf, 0xec, 0xd6, 0x68, 0xd9, 0x46, 0xde, 0x67, 0x4d,
  0x3e, 0x59, 0xad, 0xd8, 0x3d, 0x5b, 0x2e, 0x5a, 0xe9, 0x59,
  0x2e, 0x5c, 0xcc, 0x58, 0x88, 0x5b, 0xc5, 0xd4, 0xe9, 0xd7,
  0xb1, 0x58, 0x72, 0xde, 0x63, 0x59, 0x1c, 0x5f, 0x2a, 0xdf,
  0xdd, 0xde, 0x8f, 0xd5, 0xd6, 0xd7, 0xcb, 0xd7, 0x5b, 0x5f,
  0x32, 0x49, 0x9c, 0xd7, 0x99, 0xdd, 0x5e, 0x5e, 0x16, 0xd9,
  0x10, 0x55, 0xe1, 0xdc, 0xff, 0x5d, 0xa1, 0xd6, 0x00, 0x5d,
  0x59, 0xde, 0x04, 0x5f, 0x75, 0xdf, 0x20, 0x5a, 0x65, 0x50,
  0xcb, 0xdc, 0xd0, 0x5d, 0xb9, 0x58, 0xf7, 0x56, 0xb5, 0x5f,
  0x32, 0x56, 0x9d, 0xde, 0x2e, 0xdb, 0x29, 0xc9, 0x93, 0xd9,
  0xb0, 0xdd, 0x06, 0xda, 0x8a, 0x51, 0x43, 0xd5, 0xa0, 0x5d,
  0x36, 0x59, 0x1b, 0xd2, 0x62, 0xd8, 0xe4, 0xd1, 0xa3, 0x5d,
  0x4d, 0xce, 0xff, 0xdb, 0xd7, 0x59, 0x68, 0x5e, 0x28, 0x59,
  0x14, 0xdc, 0x5a, 0x5d, 0xb2, 0x53, 0x68, 0x5f, 0xca, 0x58,
  0x5f, 0xd8, 0xa3, 0xdc, 0xdd, 0x59, 0x75, 0x5b, 0xdd, 0x5a,
  0x1b, 0xdc, 0xd5, 0x58, 0x46, 0xde, 0x12, 0xdf, 0x0b, 0xdc,
  0xf4, 0x5b, 0xd7, 0x5b, 0xb5, 0x58, 0xff, 0xdb, 0x26, 0xd7,
  0x21, 0x5a, 0x7b, 0x5e, 0x5a, 0x5b, 0xe8, 0x5d, 0x49, 0xdf,
  0x50, 0x5f, 0x55, 0x5e, 0xfb, 0x4e, 0x5b, 0x5a, 0xf6, 0x5c,
  0x63, 0x5c, 0xe9, 0xde, 0xe1, 0x5b, 0x2e, 0xdf, 0x62, 0xdd,
  0x6c, 0xdb, 0xcc, 0xd5, 0xa7, 0x5c, 0x3c, 0xd7, 0xa8, 0x5d,
  0x90, 0xde, 0x22, 0xdf, 0xb7, 0x5e, 0x8a, 0xdc, 0x23, 0xd6,
  0x4d, 0xdd, 0xd9, 0xd0, 0x61, 0xd8, 0xa3, 0xdd, 0x0d, 0x4c,
  0x6f, 0x5b, 0x80, 0x5e, 0x69, 0x5b, 0x4c, 0x55, 0x44, 0xd8,
  0xd9, 0xc9, 0xbd, 0x5f, 0x6b, 0xdc, 0x97, 0xdf, 0x89, 0x5d,
  0x69, 0x51, 0x3d, 0xc8, 0x66, 0xde, 0x63, 0xdf, 0xfd, 0xdc,
  0x48, 0xcd, 0x68, 0xdd, 0x9c, 0x5c, 0x3e, 0xda, 0x1c, 0xd8,
  0x35, 0x56, 0x47, 0x54, 0x54, 0x5d, 0xcd, 0xdd, 0xcc, 0x5b,
  0xb6, 0x58, 0x8a, 0xd8, 0x2c, 0xde, 0x6e, 0x5a, 0x40, 0xdc,
  0xd5, 0x5e, 0xf5, 0xd2, 0x94, 0xdc, 0x14, 0xdc, 0xa4, 0xdc,
  0x28, 0x59, 0x59, 0xda, 0x35, 0x5a, 0xfe, 0x54, 0xb7, 0xd7,
  0xbd, 0x5e, 0xb2, 0xdb, 0xeb, 0x56, 0xe0, 0x59, 0x3f, 0x58,
  0x6e, 0xde, 0xd0, 0xdb, 0x02, 0x59, 0x02, 0xd9, 0x4f, 0xd9,
  0x3c, 0x54, 0xa7, 0xde, 0x1a, 0xda, 0x13, 0x5c, 0x87, 0xd8,
  0xd1, 0xdb, 0x96, 0xdd, 0x13, 0x5b, 0x82, 0xdc, 0x0a, 0xdf,
  0x10, 0x4f, 0xcd, 0xcb, 0xa8, 0xd4, 0x5b, 0x53, 0xe1, 0xdb,
  0x84, 0xdf, 0x24, 0xd4, 0x2d, 0xdc, 0x47, 0xde, 0x18, 0xdb,
  0x7a, 0xd7, 0xfe, 0x5a, 0x1b, 0x5d, 0x5a, 0xde, 0x49, 0xd6,
  0x03, 0xca, 0x18, 0x5b, 0x39, 0xd6, 0x3e, 0xdd, 0xb6, 0xd6,
  0x8a, 0xd6, 0x22, 0x5a, 0x9a, 0xd1, 0x48, 0x55, 0x96, 0xde,
  0x93, 0xcd, 0x19, 0x57, 0xb6, 0xd8, 0x98, 0xd4, 0x7e, 0xdf,
  0x8b, 0xdc, 0xb9, 0x5e, 0xe3, 0x5c, 0x69, 0x5e, 0x48, 0x5d,
  0x23, 0xdf, 0x90, 0x5f, 0x66, 0x5b, 0x47, 0xdf, 0x33, 0xdf,
  0xac, 0x51, 0x11, 0xda, 0xd0, 0xde, 0xa6, 0x59, 0xb0, 0x5e,
  0x08, 0x5d, 0x6f, 0xd2, 0xdb, 0x5b, 0x67, 0x5d, 0x02, 0x53,
  0xd7, 0x4f, 0x55, 0xdd, 0xdb, 0xde, 0xda, 0xcb, 0x13, 0x5d,
  0x54, 0x5d, 0xec, 0xd9, 0xd8, 0xd3, 0x5d, 0xd0, 0x0e, 0x57,
  0x8d, 0x5f, 0xb7, 0xdf, 0xbf, 0x5f, 0xf7, 0x50, 0x7c, 0xdd,
  0xc3, 0x42, 0x3f, 0xdd, 0xd0, 0x55, 0x0d, 0x5e, 0x17, 0xdc,
  0xe8, 0x5a, 0x61, 0x5f, 0x77, 0xd6, 0xa2, 0x55, 0x4b, 0x52,
  0x17, 0xdc, 0x8b, 0x5d, 0x62, 0xde, 0xd2, 0xd8, 0xbb, 0x58,
  0x79, 0xdd, 0xcf, 0x5d, 0x0e, 0xde, 0xc7, 0xd2, 0x7b, 0x5d,
  0x84, 0xdf, 0x09, 0xd4, 0x39, 0xd8, 0x23, 0xdf, 0x9d, 0xdc,
  0x98, 0xd5, 0x35, 0x59, 0x09, 0xdf, 0xeb, 0x58, 0x74, 0xd8,
  0x9d, 0x55, 0xa6, 0xdf, 0xaa, 0xdf, 0xc6, 0x5d, 0xd0, 0x57,
  0x16, 0x54, 0x76, 0x56, 0xb5, 0xd7, 0xeb, 0x54, 0xea, 0x42,
  0xa3, 0xdd, 0x93, 0xdc, 0x08, 0xdd, 0x94, 0xde, 0x8a, 0xdd,
  0x39, 0xd9, 0x2c, 0x53, 0x17, 0x5e, 0xbc, 0xde, 0xf3, 0x5d,
  0x04, 0xbf, 0xcb, 0x5d, 0x7e, 0x56, 0xc9, 0xd5, 0xea, 0xde,
  0x3a, 0x59, 0x50, 0x59, 0x3d, 0x57, 0x16, 0x5e, 0x57, 0x5d,
  0x5c, 0x52, 0x43, 0xd8, 0x52, 0x5d, 0xf7, 0x5a, 0x5f, 0x5f,
  0x91, 0x5a, 0x25, 0x5e, 0x25, 0xdd, 0x14, 0x56, 0xe6, 0xcf,
  0x07, 0x5f, 0xd6, 0x41, 0xd3, 0x5e, 0x1a, 0x5c, 0x89, 0x55,
  0xa7, 0x5c, 0x3c, 0x5f, 0xd6, 0x5a, 0xf3, 0x53, 0x70, 0xd6,
  0x96, 0x5d, 0xd6, 0xde, 0xfe, 0x56, 0xb1, 0x5e, 0xbe, 0x59,
  0xbb, 0x5c, 0x2b, 0xda, 0x20, 0xd9, 0xc1, 0x5c, 0xfe, 0x5a,
  0xee, 0x5e, 0x2c, 0xd9, 0x36, 0xdb, 0xd9, 0x50, 0x99, 0x4d,
};

static const float NUMPY_ARRAY_SAMPLE_ITEMS[] = {
  -312.5, -51.531, -86.438, -320.0, -79.438, -4.1406, -423.5, -30.516, 364.5, -465.5,
  -332.75, -410.25, 435.0, 150.5, 249.12, 88.625, 29.625, -182.25, 188.38, 133.38,
  -349.25, 389.25, 21.719, 22.422, 491.25, 366.0, -361.0, -154.5, 181.0, -306.25,
  -189.62, 102.94, 167.12, -108.62, -211.75, 144.25, 130.38, 402.0, 83.875, -401.25,
  122.0, -361.5, -345.5, -318.25, 445.75, 331.5, 83.5, 383.5, -5.1016, 338.5,
  -407.75, 123.62, -476.75, 62.875, -405.75, 364.75, -481.75, -4.7031, -267.0, -33.281,
  -477.0, 428.75, 62.312, 301.75, -143.38, -492.25, -110.75, -173.0, -401.5, 21.609,
  167.75, -149.62, 231.62, 197.75, 189.12, 267.5, 153.5, 241.0, -76.312, -126.56,
  150.12, -412.5, 172.38, 455.0, -458.5, -439.25, -88.938, -125.38, -124.69, 470.75,
  10.391, -121.75, -358.25, 407.5, -162.75, 81.0, -312.25, 383.75, -106.06, 320.0,
  -406.25, 449.0, -477.25, 196.0, 35.156, -306.75, 372.0, 151.12, 111.44, 493.25,
  99.125, -423.25, -229.75, -10.32, -178.38, -364.0, -192.75, 44.312, -84.188, 360.0,
  166.75, -48.844, -140.25, -47.125, 360.75, -25.203, -255.88, 186.88, 410.0, 165.0,
  -261.0, 342.5, 61.562, 474.0, 153.25, -139.88, -296.75, 187.62, 238.62, 219.62,
  -262.75, 154.62, -401.5, -452.5, -258.75, 254.5, 250.88, 150.62, -255.88, -114.38,
  196.12, 414.75, 235.25, 378.0, -466.25, 468.0, 405.25, 27.922, 203.38, 317.5,
  280.75, -442.25, 252.12, -459.5, -344.5, -237.5, -92.75, 297.75, -115.75, 362.0,
  -420.0, -456.5, 429.75, -290.5, -98.188, -339.25, -38.781, -140.12, -360.75, 16.203,
  237.88, 416.0, 237.12, 84.75, -136.5, -11.695, 495.25, -282.75, -485.75, 354.25,
  43.281, -8.4766, -409.5, -472.75, -319.25, -21.125, -346.0, 295.0, -199.75, -131.5,
  99.312, 68.438, 341.0, -371.25, 249.5, 150.75, -145.25, -395.0, 205.75, -272.0,
  437.25, -55.656, -293.0, -261.0, -297.0, 165.0, -203.12, 198.62, 79.875, -123.44,
  431.25, -246.25, 110.69, 188.0, 135.88, -411.5, -250.0, 160.25, -160.25, -169.88,
  67.75, -425.75, -195.25, 260.75, -144.88, -250.12, -357.5, 226.38, -288.5, -450.5,
  28.25, -15.602, -74.5, 58.844, -252.12, -481.0, -66.25, -267.25, -401.75, -227.0,
  -119.62, 223.75, 326.75, -406.5, -100.56, -12.023, 227.0, -99.562, -335.5, -107.38,
  -104.62, 196.25, -44.812, 84.5, -421.5, -22.297, 113.56, -150.75, -73.5, -479.5,
  -290.75, 430.25, 312.75, 410.25, 338.0, -456.75, 484.0, 236.75, -465.75, -460.75,
  45.375, -194.12, -436.0, 180.75, 428.0, 322.0, -51.469, 251.38, 345.75, 56.062,
  31.359, -341.25, -438.75, -15.703, 324.75, 341.0, -189.5, -62.75, -34.906, 112.88,
  483.25, -493.75, 495.75, 39.719, -351.0, 3.3809, -335.75, 93.0, 387.25, -261.75,
  221.0, 472.25, -103.44, 90.125, 50.344, -261.75, 354.75, -408.5, -154.25, 151.38,
  -350.25, 371.75, -387.5, -54.219, 350.75, -481.0, -64.562, -135.12, -456.75, -295.25,
  -89.5, 166.62, -450.25, 157.38, -142.5, 89.812, -489.5, -490.5, 369.5, 125.0,
  65.375, 103.38, -123.31, 78.688, 3.457, -360.75, -292.75, -322.0, -421.0, -354.5,
  -167.12, 57.375, 389.75, -431.0, 380.75, -1.7539, 370.75, 103.88, -92.562, -442.5,
  167.25, 170.0, 115.81, 389.5, 341.75, 50.875, -136.38, 340.5, 222.88, 471.75,
  210.12, 393.25, -329.25, 97.25, -31.594, 449.75, 2.918, 436.75, 262.5, 88.562,
  297.75, 463.0, 218.75, 63.594, -103.0, 357.5, -437.5, 111.88, 428.25, 183.75,
  302.75, -197.38, -164.0, 304.25, 223.75, 443.5, -165.5, -230.75, 38.781, 22.391,
};

TEST(NumpyArrayLoaderTest, LoadF16F32T) {
  auto loader = NumpyArrayLoader();
  auto sample = std::make_unique<imemstream<const uint8_t>>(
      NUMPY_ARRAY_SAMPLE, sizeof(NUMPY_ARRAY_SAMPLE));
  ASSERT_TRUE(sample->good());
  auto array = loader.Load<float, 2, true>(sample.get());
  EXPECT_TRUE(array.transposed);
  EXPECT_EQ(array.shape[0], 40);
  EXPECT_EQ(array.shape[1], 10);
  EXPECT_EQ(array.shape.size(), 2);
  for (int y = 0; y < 40; y++) {
    for (int x = 0; x < 10; x++) {
      auto v = array.data[x * 40 + y];
      ASSERT_NEAR(v, NUMPY_ARRAY_SAMPLE_ITEMS[y * 10 + x], fabs(v) / 1000)
          << "x = " << x << ", y = " << y;
    }
  }
}

TEST(NumpyArrayLoaderTest, LoadF16F32) {
  auto loader = NumpyArrayLoader();
  auto sample = std::make_unique<imemstream<const uint8_t>>(
      NUMPY_ARRAY_SAMPLE, sizeof(NUMPY_ARRAY_SAMPLE));
  auto array = loader.Load<float, 2>(sample.get());
  EXPECT_FALSE(array.transposed);
  EXPECT_EQ(array.shape[0], 40);
  EXPECT_EQ(array.shape[1], 10);
  EXPECT_EQ(array.shape.size(), 2);
  for (int y = 0; y < 40; y++) {
    for (int x = 0; x < 10; x++) {
      auto v = array.data[y * 10 + x];
      ASSERT_NEAR(v, NUMPY_ARRAY_SAMPLE_ITEMS[y * 10 + x], fabs(v) / 1000)
          << "x = " << x << ", y = " << y;
    }
  }
}

TEST(NumpyArrayLoaderTest, LoadF16F16) {
  auto loader = NumpyArrayLoader();
  auto sample = std::make_unique<imemstream<const uint8_t>>(
          NUMPY_ARRAY_SAMPLE, sizeof(NUMPY_ARRAY_SAMPLE));
  auto array = loader.Load<uint16_t, 2>(sample.get());
  EXPECT_FALSE(array.transposed);
  EXPECT_EQ(array.shape[0], 40);
  EXPECT_EQ(array.shape[1], 10);
  EXPECT_EQ(array.shape.size(), 2);
  const uint16_t* ref = reinterpret_cast<const uint16_t*>(
      NUMPY_ARRAY_SAMPLE + 80);
  for (int y = 0; y < 40; y++) {
    for (int x = 0; x < 10; x++) {
      auto v = array.data[y * 10 + x];
      ASSERT_EQ(v, ref[y * 10 + x]) << "x = " << x << ", y = " << y;
    }
  }
}

TEST(NumpyArrayLoaderTest, LoadF32F32) {
  auto loader = NumpyArrayLoader();
  std::unique_ptr<uint8_t[]> fake_sample(
      new uint8_t[sizeof(NUMPY_ARRAY_SAMPLE) * 2 - 80]);
  memcpy(fake_sample.get(), NUMPY_ARRAY_SAMPLE, sizeof(NUMPY_ARRAY_SAMPLE));
  memset(fake_sample.get() + sizeof(NUMPY_ARRAY_SAMPLE), 0,
         sizeof(NUMPY_ARRAY_SAMPLE) - 80);
  fake_sample[23] = '4';
  auto sample = std::make_unique<imemstream<uint8_t>>(
      fake_sample, sizeof(NUMPY_ARRAY_SAMPLE) * 2 - 80);
  auto array = loader.Load<float, 2>(sample.get());
  EXPECT_FALSE(array.transposed);
  EXPECT_EQ(array.shape[0], 40);
  EXPECT_EQ(array.shape[1], 10);
  EXPECT_EQ(array.shape.size(), 2);
  const uint32_t* ref = reinterpret_cast<const uint32_t*>(
      fake_sample.get() + 80);
  for (int y = 0; y < 40; y++) {
    for (int x = 0; x < 10; x++) {
      auto v = reinterpret_cast<uint32_t*>(array.data.get_raw())[y * 10 + x];
      ASSERT_EQ(v, ref[y * 10 + x]) << "x = " << x << ", y = " << y;
    }
  }
}

TEST(NumpyArrayLoaderTest, LoadF32F32T) {
  auto loader = NumpyArrayLoader();
  std::unique_ptr<uint8_t[]> fake_sample(
      new uint8_t[sizeof(NUMPY_ARRAY_SAMPLE) * 2 - 80]);
  memcpy(fake_sample.get(), NUMPY_ARRAY_SAMPLE, sizeof(NUMPY_ARRAY_SAMPLE));
  memset(fake_sample.get() + sizeof(NUMPY_ARRAY_SAMPLE), 0,
         sizeof(NUMPY_ARRAY_SAMPLE) - 80);
  fake_sample[23] = '4';
  auto sample = std::make_unique<imemstream<uint8_t>>(
      fake_sample, sizeof(NUMPY_ARRAY_SAMPLE) * 2 - 80);
  auto array = loader.Load<float, 2, true>(sample.get());
  EXPECT_TRUE(array.transposed);
  EXPECT_EQ(array.shape[0], 40);
  EXPECT_EQ(array.shape[1], 10);
  EXPECT_EQ(array.shape.size(), 2);
  const uint32_t* ref = reinterpret_cast<const uint32_t*>(
      fake_sample.get() + 80);
  for (int y = 0; y < 40; y++) {
    for (int x = 0; x < 10; x++) {
      auto v = reinterpret_cast<uint32_t*>(array.data.get_raw())[x * 40 + y];
      ASSERT_EQ(v, ref[y * 10 + x]) << "x = " << x << ", y = " << y;
    }
  }
}

}  // namespace internal

}  // namespace veles

#include "tests/google/src/gtest_main.cc"

